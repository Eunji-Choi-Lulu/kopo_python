# -*- coding: utf-8 -*-
"""opencv 연습.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ldmrfDEZdPmF4Dl3xEc2qn2hY0R9Q13

###1. 침식 & 팽창
"""

from google.colab import drive
drive.mount('/content/drive')

import cv2
import numpy as np
from matplotlib import pyplot as plt

orig = cv2.imread('/content/drive/MyDrive/Colab Notebooks/과제 및 연습장/KOPO로고.png')

orig

# cv2.erode(): 흰색 영역을 깎아냄
# cv2.dilate(): 흰색 영역을 늘림
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))

erosion = cv2.erode(orig, kernel, iterations = 2)
dilation = cv2.dilate(orig, kernel, iterations = 2)
images = [orig, erosion, dilation]
titles = ['Origin', 'Erosion', 'Dilation']

for i in range (3):
    plt.subplot(3,1,i+1), plt.imshow(images[i]), plt.title(titles[i])
    plt.xticks([]),plt.yticks([])

plt.show()

"""###2. 이미지 반전 후 적용"""

img2 = cv2.imread('/content/drive/MyDrive/Colab Notebooks/과제 및 연습장/KOPO로고.png', cv2.IMREAD_GRAYSCALE)

# 이미지 반전(배경을 검정, 글자는 흰색으로)
inverted = cv2.bitwise_not(img2)

# 커널 생성
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))
erosion = cv2.erode(inverted, kernel, iterations = 2)
dilation = cv2.dilate(inverted, kernel, iterations = 2)
images = [inverted, erosion, dilation]
titles = ['Inverted', 'Erosion', 'Dilation']

for i in range (3):
    # 3개 이미지를 세로 방향으로 나란히 배치
    plt.subplot(3,1,i+1)
    # 이미지를 화면에 출력. 이때 cmap='gray'를 넣어 회색조 표시
    # 안 넣으면 matplotlib가 컬러맵을 임의로 적용해 보라색 등 이상한 색이 나올 수 있음
    plt.imshow(images[i], cmap='gray')
    # 그림 위에 제목 표시
    plt.title(titles[i])
    # 이미지에 숫자 좌표 안나오게 설정
    plt.xticks([]),plt.yticks([])

plt.show()

"""###3. 이미지 필터링"""

# 5x5 크기의 필터를 이미지 위에 이동시키면서,
# 해당 영역(5x5 픽셀)의 평균 값을 계산해서
# 그 결과를 중심 픽셀에 적용하는 방식
# 필터가 이미지의 영역을 벗어나는 경우에는, 패딩처리 지원

img3 = cv2.imread('/content/drive/MyDrive/Colab Notebooks/과제 및 연습장/KOPO로고.png')

# 5x5 크기의 블러 필터 생성
# np.ones =  모든 값이 1인 배열을 만들어 주는 함수
# 합성곱: 필터와 원본 이미지의 값을 곱해서 더하고 나누는 과정
kernel = np.ones((5,5), np.float32) / 25

# 이미지에 필터 적용
dst =  cv2.filter2D(img3, -1, kernel)

plt.figure(figsize=(10, 4))

# subplot함수는 한 화면에 여러개의 이미지를 나누어 배치할 때 사용
# plt.subplot(행 개수, 열 개수, 위치번호)

# 1. 원본 이미지 출력
plt.subplot(1, 2, 1)
plt.imshow(img3)
plt.title('Original')
plt.axis('off')

# 2. 필터 적용된 이미지 출력
plt.subplot(1, 2, 2)
plt.imshow(dst)
plt.title('Filtered (Blurred)')
plt.axis('off')

"""### 4. 이미지 사이즈 변경 (Scaling)"""

# 스케일링: 이미지에 대한 크기를 변경하는것
# cv2.resize()함수 사용

img4 = cv2.imread('/content/drive/MyDrive/Colab Notebooks/과제 및 연습장/KOPO로고.png')
height, width = img4.shape[:2]

# 이미지 리사이즈
# 1. 원본 이미지 70% 축소, 보간법: INTER_AREA
res1 = cv2.resize(img4, None, fx=0.7, fy = 0.7, interpolation = cv2.INTER_AREA)

# 2. 원본 이미지 200% 확대, 보간법: INTER_CUBIC
res2 = cv2.resize(img4, (2*width, 2*height), interpolation = cv2.INTER_CUBIC)

# 원본 이미지 출력
plt.subplot(1, 3, 1)
plt.imshow(img4)
plt.title(f'Orinal\n{img4.shape[1]}x{img4.shape[0]}')
plt.axis('off')

# 축소 이미지 출력
plt.subplot(1, 3, 2)
plt.imshow(res1)
plt.title(f'Size Down\n{res1.shape[1]}x{res1.shape[0]}')
plt.axis('off')

# 확대 이미지 출력
plt.subplot(1, 3, 3)
plt.imshow(res2)
plt.title(f'Size Up\n{res2.shape[1]}x{res2.shape[0]}')
plt.axis('off')

